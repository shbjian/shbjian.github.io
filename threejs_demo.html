<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Three.js æ‰‹åŠ¿ç‰¹æ•ˆç‰ˆ - Gemini 3 Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <style>
        body { margin: 0; overflow: hidden; background-color: #000; touch-action: none; }
        #canvas-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; }
        #video-element { transform: scaleX(-1); opacity: 0; position: absolute; pointer-events: none;}
        
        /* HUD æ ·å¼ */
        .hud { position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%); z-index: 10; 
               display: flex; gap: 15px; pointer-events: none; }
        .hud-item { background: rgba(0,0,0,0.6); border: 1px solid rgba(255,255,255,0.2); 
                    padding: 8px 16px; border-radius: 20px; color: #fff; font-size: 14px; 
                    transition: all 0.3s ease; opacity: 0.5; backdrop-filter: blur(5px); }
        .hud-item.active { background: rgba(79, 172, 254, 0.4); border-color: #4facfe; opacity: 1; transform: scale(1.1); font-weight: bold; box-shadow: 0 0 15px rgba(79, 172, 254, 0.5); }
    </style>
</head>
<body>

    <!-- HUD çŠ¶æ€æ  -->
    <div class="hud">
        <div id="status-open" class="hud-item">ğŸ–ï¸ æ‰©æ•£</div>
        <div id="status-pinch" class="hud-item">ğŸ‘Œ èšèƒ½</div>
        <div id="status-fist" class="hud-item">âœŠ å†»ç»“</div>
    </div>

    <div class="absolute top-4 left-4 z-20 text-white opacity-70 text-xs">
        <div id="fps-counter">FPS: --</div>
    </div>

    <div id="canvas-container"></div>
    <video id="video-element" playsinline></video>

<script>
    // --- é…ç½®å‚æ•° ---
    const CONFIG = {
        particleCount: 1500, // æ‰‹æœºç«¯å»ºè®®ç¨å¾®å‡å°‘ç²’å­æ•°
        baseSpeed: 0.05,
        colors: {
            normal: new THREE.Color(0x00ffff), // é’è‰²
            pinch: new THREE.Color(0xff0055),  // çº¢è‰²ï¼ˆèšèƒ½ï¼‰
            open: new THREE.Color(0xffff00),   // é»„è‰²ï¼ˆæ‰©æ•£ï¼‰
            fist: new THREE.Color(0xffffff)    // ç™½è‰²ï¼ˆå†»ç»“ï¼‰
        }
    };

    // --- 1. Three.js åˆå§‹åŒ– ---
    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x000000, 0.002);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 120;

    const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" }); // æ€§èƒ½ä¼˜åŒ–
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); // é™åˆ¶DPRé˜²æ­¢æ‰‹æœºè¿‡çƒ­
    container.appendChild(renderer.domElement);

    // --- 2. ç²’å­ç³»ç»Ÿæ„å»º ---
    const geometry = new THREE.BufferGeometry();
    const positions = new Float32Array(CONFIG.particleCount * 3);
    const velocities = new Float32Array(CONFIG.particleCount * 3);
    const colors = new Float32Array(CONFIG.particleCount * 3);
    const initialPos = new Float32Array(CONFIG.particleCount * 3); // è®°ä½åˆå§‹ä½ç½®ç”¨äºå¤ä½

    for (let i = 0; i < CONFIG.particleCount; i++) {
        const x = (Math.random() - 0.5) * 400;
        const y = (Math.random() - 0.5) * 200;
        const z = (Math.random() - 0.5) * 100;

        positions[i * 3] = initialPos[i * 3] = x;
        positions[i * 3 + 1] = initialPos[i * 3 + 1] = y;
        positions[i * 3 + 2] = initialPos[i * 3 + 2] = z;

        colors[i * 3] = CONFIG.colors.normal.r;
        colors[i * 3 + 1] = CONFIG.colors.normal.g;
        colors[i * 3 + 2] = CONFIG.colors.normal.b;
    }

    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));

    // ä½¿ç”¨è‡ªå®šä¹‰ç€è‰²å™¨çš„æè´¨ä¼šè®©ç²’å­æ›´å¥½çœ‹ï¼Œè¿™é‡Œä¸ºäº†ç®€æ´ä½¿ç”¨ PointsMaterial
    const material = new THREE.PointsMaterial({
        size: 3.0,
        vertexColors: true,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        map: (() => {
            // ç”Ÿæˆä¸€ä¸ªç®€å•çš„åœ†å½¢çº¹ç†ï¼Œæ¯”æ–¹å—å¥½çœ‹
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        })()
    });

    const particles = new THREE.Points(geometry, material);
    scene.add(particles);

    // --- 3. æ‰‹åŠ¿é€»è¾‘çŠ¶æ€ ---
    const state = {
        handActive: false,
        x: 0, y: 0,
        gesture: 'none', // 'pinch', 'open', 'fist', 'none'
        gestureSmooth: 'none'
    };

    // UI å…ƒç´ 
    const ui = {
        open: document.getElementById('status-open'),
        pinch: document.getElementById('status-pinch'),
        fist: document.getElementById('status-fist'),
        fps: document.getElementById('fps-counter')
    };

    function updateUI(gesture) {
        ui.open.classList.toggle('active', gesture === 'open');
        ui.pinch.classList.toggle('active', gesture === 'pinch');
        ui.fist.classList.toggle('active', gesture === 'fist');
    }

    // --- 4. MediaPipe æ•°æ®å¤„ç† ---
    function onResults(results) {
        if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
            state.handActive = false;
            if(state.gesture !== 'none') {
                state.gesture = 'none';
                updateUI('none');
            }
            return;
        }

        const landmarks = results.multiHandLandmarks[0];
        state.handActive = true;

        // 1. è·å–æ ¸å¿ƒç‚¹ä½
        const wrist = landmarks[0];
        const thumbTip = landmarks[4];
        const indexTip = landmarks[8];
        const middleTip = landmarks[12];
        const ringTip = landmarks[16];
        const pinkyTip = landmarks[20];

        // 2. åæ ‡æ˜ å°„ (2D -> 3D)
        // é€‚å½“è°ƒæ•´ç³»æ•°ä»¥é€‚é…å±å¹•
        const targetX = (0.5 - indexTip.x) * 350; 
        const targetY = (0.5 - indexTip.y) * 250;
        
        // å¹³æ»‘æ’å€¼
        state.x += (targetX - state.x) * 0.15;
        state.y += (targetY - state.y) * 0.15;

        // 3. ç®€å•æ‰‹åŠ¿è¯†åˆ«é€»è¾‘
        
        // è®¡ç®—æŒ‡å°–åˆ°æ‰‹è…•çš„è·ç¦»ï¼Œåˆ¤æ–­æ‰‹æŒ‡æ˜¯å¦ä¼¸ç›´
        const dist = (p1, p2) => Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        
        // æåˆï¼šæ‹‡æŒ‡ä¸é£ŸæŒ‡è·ç¦»æè¿‘
        const pinchDist = dist(thumbTip, indexTip);
        
        // æ¡æ‹³ï¼šæ‰€æœ‰æŒ‡å°–éƒ½é è¿‘æ‰‹è…• (ç®€åŒ–åˆ¤æ–­ï¼šä¸­æŒ‡å°–é è¿‘æ‰‹è…•)
        const middleToWrist = dist(middleTip, wrist);
        
        let currentGesture = 'normal';

        if (pinchDist < 0.05) {
            currentGesture = 'pinch';
        } else if (middleToWrist < 0.15) { 
            // è¿™æ˜¯ä¸€ä¸ªè¿‘ä¼¼å€¼ï¼Œæ ¹æ®æ‰‹çš„å¤§å°å¯èƒ½éœ€è¦å¾®è°ƒ
            currentGesture = 'fist';
        } else if (middleToWrist > 0.3) {
            // æ‰‹æŒ‡å¼ å¾—å¾ˆå¼€
            currentGesture = 'open';
        } else {
            currentGesture = 'normal';
        }

        if (state.gesture !== currentGesture) {
            state.gesture = currentGesture;
            updateUI(currentGesture);
        }
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 0, // æ‰‹æœºç«¯æ”¹ä¸º0ä»¥æå‡æ€§èƒ½
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });
    hands.onResults(onResults);

    const videoElement = document.getElementById('video-element');
    const cameraUtils = new Camera(videoElement, {
        onFrame: async () => { await hands.send({image: videoElement}); },
        width: 640, // é™ä½åˆ†è¾¨ç‡ä»¥æå‡æ€§èƒ½
        height: 480
    });
    cameraUtils.start();

    // --- 5. åŠ¨ç”»ç‰©ç†å¾ªç¯ ---
    let lastTime = 0;
    
    function animate(time) {
        requestAnimationFrame(animate);

        // FPS ç®€å•è®¡ç®—
        if (time - lastTime > 1000) {
            ui.fps.innerText = `FPS: ${Math.round(1000 / ((time - lastTime) / 60))}`; // ç²—ç•¥ä¼°ç®—
            lastTime = time;
        }

        const positionsArr = particles.geometry.attributes.position.array;
        const colorsArr = particles.geometry.attributes.color.array; // ä¿®æ­£å˜é‡åé”™è¯¯
        
        // ç¡®å®šç›®æ ‡é¢œè‰²
        let targetColor = CONFIG.colors.normal;
        if (state.gesture === 'pinch') targetColor = CONFIG.colors.pinch;
        if (state.gesture === 'open') targetColor = CONFIG.colors.open;
        if (state.gesture === 'fist') targetColor = CONFIG.colors.fist;

        for (let i = 0; i < CONFIG.particleCount; i++) {
            const idx = i * 3;
            let px = positionsArr[idx];
            let py = positionsArr[idx+1];
            let pz = positionsArr[idx+2];
            
            let vx = velocities[idx];
            let vy = velocities[idx+1];
            let vz = velocities[idx+2];

            // --- ç‰©ç†å¼•æ“æ ¸å¿ƒ ---
            
            if (state.handActive) {
                const dx = state.x - px;
                const dy = state.y - py;
                const dz = -pz;
                const distSq = dx*dx + dy*dy + dz*dz;
                const dist = Math.sqrt(distSq);

                // ç‰¹æ•ˆ 1: å†»ç»“ (Fist)
                if (state.gesture === 'fist') {
                    // å¼ºåŠ›é˜»å°¼è®©ç²’å­åœä¸‹
                    vx *= 0.8; vy *= 0.8; vz *= 0.8;
                    // ç¨å¾®é¢¤æŠ–
                    vx += (Math.random()-0.5)*0.1;
                    vy += (Math.random()-0.5)*0.1;
                } 
                // ç‰¹æ•ˆ 2: æœ‰åŠ›å¸å¼•/é»‘æ´ (Pinch)
                else if (state.gesture === 'pinch') {
                    if (dist > 5) { // é˜²æ­¢é™¤ä»¥0çˆ†ç‚¸
                        const force = 1000 / distSq; 
                        vx += dx * 0.002 * force;
                        vy += dy * 0.002 * force;
                        vz += dz * 0.002 * force;
                    }
                }
                // ç‰¹æ•ˆ 3: æ–¥åŠ›/å†²å‡»æ³¢ (Open)
                else if (state.gesture === 'open') {
                    if (dist < 150) {
                        const force = (150 - dist) * 0.001; // è·ç¦»è¶Šè¿‘æ–¥åŠ›è¶Šå¤§
                        vx -= dx * force;
                        vy -= dy * force;
                        vz -= dz * force; // æ¨å‘å››å‘¨
                    }
                }
                // é»˜è®¤çŠ¶æ€: æ¸©å’Œå¸å¼•
                else {
                    if (dist < 100) {
                        vx += dx * 0.0005;
                        vy += dy * 0.0005;
                    }
                }
            }

            // åŸºç¡€ç‰©ç†ï¼šç¨å¾®å›å½’åˆå§‹ä½ç½®ï¼ˆå¼¹æ€§ï¼‰
            if (state.gesture !== 'fist' && state.gesture !== 'pinch') {
                 vx += (initialPos[idx] - px) * 0.001;
                 vy += (initialPos[idx+1] - py) * 0.001;
                 vz += (initialPos[idx+2] - pz) * 0.001;
            }

            // é˜»å°¼
            vx *= 0.95; vy *= 0.95; vz *= 0.95;

            // æ›´æ–°ä½ç½®
            positionsArr[idx] += vx;
            positionsArr[idx+1] += vy;
            positionsArr[idx+2] += vz;

            // å­˜å›é€Ÿåº¦
            velocities[idx] = vx;
            velocities[idx+1] = vy;
            velocities[idx+2] = vz;

            // é¢œè‰²æ¸å˜
            colorsArr[idx] += (targetColor.r - colorsArr[idx]) * 0.1;
            colorsArr[idx+1] += (targetColor.g - colorsArr[idx+1]) * 0.1;
            colorsArr[idx+2] += (targetColor.b - colorsArr[idx+2]) * 0.1;
        }

        particles.geometry.attributes.position.needsUpdate = true;
        particles.geometry.attributes.color.needsUpdate = true;
        
        // åœºæ™¯å¾®åŠ¨
        scene.rotation.y = Math.sin(time * 0.0002) * 0.1;

        renderer.render(scene, camera);
    }

    animate(0);

    // çª—å£è‡ªé€‚åº”
    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>
